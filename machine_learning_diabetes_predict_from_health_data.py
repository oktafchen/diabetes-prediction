# -*- coding: utf-8 -*-
"""Machine Learning Diabetes Predict from health data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rFaC8NcdDWVYuY4kdTaZ7W4n0WfgCpyZ

#Load Data
"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("uciml/pima-indians-diabetes-database")

print("Path to dataset files:", path)

"""#data understanding and check missing values"""

import pandas as pd

import numpy as np

import seaborn as sns
import matplotlib.pyplot as plt

from sklearn.preprocessing import MinMaxScaler
from sklearn import tree
from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report
from sklearn.model_selection import (
  cross_validate,
  train_test_split,
)
from sklearn.neighbors import KNeighborsClassifier

df = pd.read_csv(path + "/diabetes.csv")
df.shape

df.sample(5)

df.info()

"""#Check Duplicates"""

df.drop_duplicates().shape

df.groupby(df.columns.tolist()).size().sort_values(ascending=False).head()

df = df.drop_duplicates()
df.shape

df.sample(5)

"""#Multicorr Check"""

sns.heatmap(df.corr(), annot=True)

"""#Outlier Check"""

for col in df.select_dtypes(include='number').columns:
    if col != 'Outcome':
        plt.figure(figsize=(6, 4))
        sns.boxplot(x='Outcome', y=col, data=df)
        plt.title(f'Boxplot {col} vs Outcome')
        plt.tight_layout()
        plt.show()

"""#EDA"""

target_column = 'Outcome'

numeric_columns = [
  'Pregnancies',
  'Glucose',
  'BloodPressure',
  'SkinThickness',
  'Insulin',
  'BMI',
  'DiabetesPedigreeFunction',
  'Age',
]

"""##Target"""

df.groupby(target_column).size()

268 / (500+268)

"""##Biavariate analysis

###Numeric vs Numeric
"""

df_corr = df[numeric_columns].corr(method='spearman')
df_corr

mask = np.zeros_like(df_corr, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True

sns.heatmap(
  df_corr,
  vmin = -1,
  vmax = 1,
  annot = True,
  mask = mask,
  fmt = '.2f',
  cmap = 'RdBu_r',
)

sns.pairplot(df[numeric_columns])

"""#Preprocess Data"""

X_train, X_test, y_train, y_test = train_test_split(
  df.drop(columns=target_column),
  df[target_column],
  test_size=0.2,
  random_state=42,
  stratify=df[target_column],
)

X_train.shape

X_test.shape

"""##Tranformation Data"""

units = {
  'Pregnancies': 1,
  'Glucose': 1,
  'BloodPressure': 1,
  'SkinThickness': 1,
  'Insulin': 1,
  'BMI': 1,
  'DiabetesPedigreeFunction': 1,
  'Age': 1,
}

# Inisialisasi scaler
scaler = MinMaxScaler()

# Fit dan transform
X_train_scaled = scaler.fit_transform(X_train[numeric_columns])
X_test_scaled = scaler.transform(X_test[numeric_columns])

# Buat nama kolom baru
scaled_columns = [col + 'Scaled' for col in numeric_columns]

# Tambahkan hasil scaling ke X_train dan X_test
X_train[scaled_columns] = pd.DataFrame(X_train_scaled, columns=scaled_columns, index=X_train.index)
X_test[scaled_columns] = pd.DataFrame(X_test_scaled, columns=scaled_columns, index=X_test.index)

# Drop kolom asli
X_train = X_train.drop(columns=numeric_columns)
X_test = X_test.drop(columns=numeric_columns)

# Ambil info dari scaler
mins = scaler.data_min_
maxs = scaler.data_max_
scales = scaler.scale_
changes = [scale * units[col] for scale, col in zip(scales, numeric_columns)]

# Tampilkan DataFrame hasil analisis
pd.DataFrame({
  'column': numeric_columns,
  'unit': [units[c] for c in numeric_columns],
  'min': mins,
  'max': maxs,
  'change': changes,
})

X_train.sample(5)

X_test.sample(5)

"""#Select Model (Basic)

##kNN

###Train
"""

model = KNeighborsClassifier(n_neighbors = 5)
model.fit(X_train, y_train)

"""###Evaluate"""

y_train_pred = model.predict(X_train)
print(classification_report(y_train, y_train_pred))

y_test_pred = model.predict(X_test)
print(classification_report(y_test, y_test_pred))

"""###Interpret"""

sns.scatterplot(
  X_train,
  x='GlucoseScaled',
  y='BMIScaled',
  hue=y_train,
  palette='muted',
)

"""##Logistic Regression

###Train
"""

model = LogisticRegression(
  penalty = 'l2',
  C = 1.0,
  solver = 'lbfgs',
  random_state = 11,
)

model.fit(X_train, y_train)

"""###Evaluate"""

y_train_pred = model.predict(X_train)
print(classification_report(y_train, y_train_pred))

y_test_pred = model.predict(X_test)
print(classification_report(y_test, y_test_pred))

"""###Interpret"""

df_feature = pd.DataFrame({
  'feature': X_train.columns,
  'coef': model.coef_[0],
  'coef_abs': abs(model.coef_[0]),
})
df_feature['polar'] = np.where(
  df_feature['coef'] < 0,
  'negative',
  'positive'
)

df_feature = df_feature.sort_values('coef_abs', ascending=False)
df_feature

ax = sns.barplot(
  df_feature,
  x='coef',
  y='feature',
  hue='polar',
  palette={'positive': 'blue', 'negative': 'red'},
  legend=False,
)
ax.bar_label(ax.containers[0], fmt='%.1f')
ax.bar_label(ax.containers[1], fmt='%.1f')
ax.set_xlim(-3, 2)

"""##Random Forest

###Train
"""

model = RandomForestClassifier(
  n_estimators = 100,
  criterion = 'gini',
  max_depth = 5,
  ccp_alpha = 0.0,
  random_state = 11,
)

model.fit(X_train, y_train)

"""###Evaluate"""

y_train_pred = model.predict(X_train)
print(classification_report(y_train, y_train_pred))

y_test_pred = model.predict(X_test)
print(classification_report(y_test, y_test_pred))

"""###Interpret"""

df_feature_importance = pd.DataFrame({
  'feature': model.feature_names_in_,
  'feature_importance': model.feature_importances_,
}).sort_values('feature_importance', ascending=False)

sns.barplot(
  df_feature_importance,
  x = 'feature_importance',
  y = 'feature',
)

"""##Smote

###SMOTE to Train Data
"""

from imblearn.over_sampling import SMOTE

# Terapkan SMOTE ke data train
smote = SMOTE(random_state=42)
X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)

print("Sebelum SMOTE:", y_train.value_counts())
print("Setelah SMOTE:", pd.Series(y_train_resampled).value_counts())

"""##XGBoost

###Train and Evaluate
"""

from xgboost import XGBClassifier
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score, RocCurveDisplay

# Inisialisasi model
xgb = XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42)

# Latih model
xgb.fit(X_train_resampled, y_train_resampled)

# Prediksi
y_pred_xgb = xgb.predict(X_test)
y_proba_xgb = xgb.predict_proba(X_test)[:, 1]  # Probabilitas untuk ROC

# Evaluasi
print("=== Classification Report (XGBoost) ===")
print(classification_report(y_test, y_pred_xgb))

print("=== Confusion Matrix ===")
print(confusion_matrix(y_test, y_pred_xgb))

# ROC AUC Score
auc = roc_auc_score(y_test, y_proba_xgb)
print(f"ROC AUC Score: {auc:.3f}")

# ROC Curve
RocCurveDisplay.from_estimator(xgb, X_test, y_test)
plt.title("ROC Curve - XGBoost")
plt.show()

"""###Interpret"""

# Ambil fitur dan importance dari model
feature_importance = xgb.feature_importances_
features = X_train_resampled.columns

# Dataframe importance
importance_df = pd.DataFrame({
    'Feature': features,
    'Importance': feature_importance
}).sort_values(by='Importance', ascending=False)

# Visualisasi
plt.figure(figsize=(8, 5))
sns.barplot(x='Importance', y='Feature', data=importance_df.head(10))
plt.title("Top 10 Feature Importances - XGBoost")
plt.tight_layout()
plt.show()

"""#Import Model"""

import joblib
joblib.dump(xgb, "xgb_diabetes_model.pkl")

"""#Save Scaler"""

import joblib
joblib.dump(scaler, "scaler.pkl")

"""#Testing input new data (Testing Model)"""

# Load model dan scaler
model = joblib.load("xgb_diabetes_model.pkl")
scaler = joblib.load("scaler.pkl")

# Data baru (misalnya dari user)
input_data = pd.DataFrame([{
    'Pregnancies': 2,
    'Glucose': 140,
    'BloodPressure': 80,
    'SkinThickness': 32,
    'Insulin': 94,
    'BMI': 35.0,
    'DiabetesPedigreeFunction': 0.5,
    'Age': 45
}])

# Scaling + Prediksi
input_scaled = scaler.transform(input_data)
pred = model.predict(input_scaled)
proba = model.predict_proba(input_scaled)[0][1]

# Hasil
print("Prediksi:", "Diabetes" if pred[0] == 1 else "Tidak Diabetes")
print(f"Probabilitas Diabetes: {proba*100:.1f}%")

from google.colab import files

# Download model dan scaler
files.download('xgb_diabetes_model.pkl')
files.download('scaler.pkl')